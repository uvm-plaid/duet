-- frank wolfe (matching the paper)

-- issues:
-- 1. The paper has a bug: The call to exponential returns a signed number which
--    gets used as an idx. This version returns a pair from exponential and (correctly)
--    does the multiplication afterwards.
-- 2. The paper has another bug: "n" is unbound in the 4th line.
-- 3. This version doesn't do clipping (it assumes the input is clipped).
-- 4. We need pairs
-- 5. The paper version uses pattern matching, but this version uses fst[] and snd[]
-- 6. We need vector update (â†¦)
-- 7. We need idx arithmetic: j mod d better be an "idx d" even if j is an "idx 2d".
-- 8. Doesn't parse
-- 9. Doesn't typecheck

let main = pÎ» m  : â„•,
              n  : â„•,
              Îµ  : â„âº.
              xs : ğ•„ [Lâˆ Lâˆ|m,n] ğ”», -- FIX: this is so we don't need clipping for now
              ys : ğ•„ [Lâˆ U|m,1] ğ”»,
              Îµ  : â„âº[Îµ] â‡’
  let k = â„•[1000] in
  let Î´ = â„âº[1.0e-6] in
  let d = cols xs in
  let mâ‚€ = mcreate[ Lâˆ | â„•[1] , d ] { i , j â‡’ 0.0 } in
  let idxs = mcreate[ Lâˆ | â„•[1] , â„•[1]â‹…d ] { i , j â‡’ âŸ¨ j mod d, sign (j - dyn d) âŸ© } in

  aloop[ Î´ ] k on mâ‚€ <xs,ys> { t , Î¸ â‡’
    let Î¼ = 1.0 / ((real t)+2.0) in
    let s = â„âº[1.0] / real (rows xs) in
    p â† exponential[s, Îµ] idxs { x â‡’ let âŸ¨c, sâŸ© = x in let g = âˆ‡[ LR Lâˆ | Î¸ ; xs , ys ] in âŸ¨ g#[0, c], s âŸ© } ;
    let gâ‚€ = mcreate[ Lâˆ | â„•[1] , d ] { i , j â‡’ 0.0 } in
    let gâ‚š = (let âŸ¨i, sâŸ© = p in gâ‚€#[0,i â†¦ real (s â‹… 100)]) in
    return ((1.0-Î¼) â‹… Î¸) + (Î¼ â‹… (100.0 â‹… gâ‚š))
  }
in main

